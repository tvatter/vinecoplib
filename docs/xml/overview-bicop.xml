<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="overview-bicop" kind="page">
    <compoundname>overview-bicop</compoundname>
    <title>Bivariate copula models</title>
    <detaileddescription>
<para>Bivariate copula models are implemented as the <computeroutput>Bicop</computeroutput> class, and <computeroutput>BicopFamily</computeroutput> is a closely related enum class describing the type or &quot;family&quot; of copula. To use bivariate copula models in your code, include the header <computeroutput><ref refid="bicop_2class_8hpp_source" kindref="compound">vinecopulib/bicop/class.hpp</ref></computeroutput> (or simply <computeroutput><ref refid="vinecopulib_8hpp_source" kindref="compound">vinecopulib.hpp</ref></computeroutput>) at the top of your source file.</para><sect1 id="overview-bicop_1Implemented">
<title>bivariate copula families</title>
<para><table rows="13" cols="3"><row>
<entry thead="yes"><para>type </para></entry><entry thead="yes"><para>name </para></entry><entry thead="yes"><para>BicopFamily  </para></entry></row>
<row>
<entry thead="no"><para>- </para></entry><entry thead="no"><para>Independence </para></entry><entry thead="no"><para>indep </para></entry></row>
<row>
<entry thead="no"><para>Elliptical </para></entry><entry thead="no"><para>Gaussian </para></entry><entry thead="no"><para>gaussian </para></entry></row>
<row>
<entry thead="no"><para></para></entry><entry thead="no"><para>Student t </para></entry><entry thead="no"><para>student </para></entry></row>
<row>
<entry thead="no"><para>Archimedean </para></entry><entry thead="no"><para>Clayton </para></entry><entry thead="no"><para>clayton </para></entry></row>
<row>
<entry thead="no"><para></para></entry><entry thead="no"><para>Gumbel </para></entry><entry thead="no"><para>gumbel </para></entry></row>
<row>
<entry thead="no"><para></para></entry><entry thead="no"><para>Frank </para></entry><entry thead="no"><para>frank </para></entry></row>
<row>
<entry thead="no"><para></para></entry><entry thead="no"><para>Joe </para></entry><entry thead="no"><para>joe </para></entry></row>
<row>
<entry thead="no"><para></para></entry><entry thead="no"><para>BB1 </para></entry><entry thead="no"><para>bb1 </para></entry></row>
<row>
<entry thead="no"><para></para></entry><entry thead="no"><para>BB6 </para></entry><entry thead="no"><para>bb6 </para></entry></row>
<row>
<entry thead="no"><para></para></entry><entry thead="no"><para>BB7 </para></entry><entry thead="no"><para>bb7 </para></entry></row>
<row>
<entry thead="no"><para></para></entry><entry thead="no"><para>BB8 </para></entry><entry thead="no"><para>bb8 </para></entry></row>
<row>
<entry thead="no"><para>Nonparametric </para></entry><entry thead="no"><para>Transformation kernel </para></entry><entry thead="no"><para>tll </para></entry></row>
</table>
Note that several convenience vectors of families are included in the sub-namespace <computeroutput>bicop_families</computeroutput>:<itemizedlist>
<listitem><para><computeroutput>all</computeroutput> contains all the families</para></listitem><listitem><para><computeroutput>parametric</computeroutput> contains the parametric families (all except <computeroutput>tll</computeroutput>)</para></listitem><listitem><para><computeroutput>nonparametric</computeroutput> contains the nonparametric families (<computeroutput>indep</computeroutput> and <computeroutput>tll</computeroutput>)</para></listitem><listitem><para><computeroutput>one_par</computeroutput> contains the parametric families with a single parameter (<computeroutput>gaussian</computeroutput>, <computeroutput>clayton</computeroutput>, <computeroutput>gumbel</computeroutput>, <computeroutput>frank</computeroutput>, and <computeroutput>joe</computeroutput>)</para></listitem><listitem><para><computeroutput>two_par</computeroutput> contains the parametric families with two parameters (<computeroutput>student</computeroutput>, <computeroutput>bb1</computeroutput>, <computeroutput>bb6</computeroutput>, <computeroutput>bb7</computeroutput>, and <computeroutput>bb8</computeroutput>)</para></listitem><listitem><para><computeroutput>elliptical</computeroutput> contains the elliptical families</para></listitem><listitem><para><computeroutput>archimedean</computeroutput> contains the archimedean families</para></listitem><listitem><para><computeroutput>bb</computeroutput> contains the BB families</para></listitem><listitem><para><computeroutput>itau</computeroutput> families for which estimation by Kendall&apos;s tau inversion is available (<computeroutput>indep</computeroutput>,<computeroutput>gaussian</computeroutput>, <computeroutput>student</computeroutput>,<computeroutput>clayton</computeroutput>, <computeroutput>gumbel</computeroutput>, <computeroutput>frank</computeroutput>, <computeroutput>joe</computeroutput>)</para></listitem></itemizedlist>
</para><para><programlisting><codeline><highlight class="normal">//<sp/>print<sp/>all<sp/>available<sp/>families</highlight></codeline>
<codeline><highlight class="normal">std::cout<sp/>&lt;&lt;<sp/>&quot;Available<sp/>families<sp/>:<sp/>&quot;;</highlight></codeline>
<codeline><highlight class="normal">for<sp/>(auto<sp/>family<sp/>:<sp/>vinecopulib::bicop_families::all)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>get_family_name(family)<sp/>&lt;&lt;<sp/>&quot;<sp/>&quot;;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect1>
<sect1 id="overview-bicop_1bicop-custom">
<title>Set up a custom bivariate copula model</title>
<para>There are essentially two ways of setting-up bivariate copulas:<itemizedlist>
<listitem><para>with known parameters,</para></listitem><listitem><para>from data (i.e., with estimated parameters).</para></listitem></itemizedlist>
</para><para>The constructor with known parameters takes 3 arguments:<itemizedlist>
<listitem><para>The copula family (default to <computeroutput>indep</computeroutput>)</para></listitem><listitem><para>The rotation (default to <computeroutput>0</computeroutput>)</para></listitem><listitem><para>The parameters (default to parameters corresponding to an independence copula)</para></listitem></itemizedlist>
</para><para><programlisting><codeline><highlight class="normal">//<sp/>90<sp/>degree<sp/>rotated<sp/>Clayton<sp/>with<sp/>default<sp/>parameter<sp/>(corresponds<sp/>to<sp/>independence)</highlight></codeline>
<codeline><highlight class="normal">Bicop<sp/>clayton(BicopFamily::clayton,<sp/>90);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Gauss<sp/>copula<sp/>with<sp/>parameter<sp/>0.5</highlight></codeline>
<codeline><highlight class="normal">Bicop<sp/>gauss(BicopFamily::gaussian,<sp/>0,<sp/><sp/>Eigen::VectorXd::Constant(1,<sp/>0.5));</highlight></codeline>
</programlisting> The constructor from data takes the same arguments as the select method and is described in the next section.</para></sect1>
<sect1 id="overview-bicop_1bicop-fit">
<title>Fit and select a bivariate copula</title>
<para>You can either fit the parameters of a given <computeroutput>Bicop</computeroutput> object with <computeroutput>fit()</computeroutput> or select the best fitting model from a set of families with <computeroutput>select()</computeroutput>.</para><para><programlisting><codeline><highlight class="normal">create<sp/>a<sp/>Gauss<sp/>copula<sp/>with<sp/>parameter<sp/>0.5<sp/>and<sp/>simulate<sp/>1e3<sp/>observations</highlight></codeline>
<codeline><highlight class="normal">Bicop<sp/>model(BicopFamily::gaussian,<sp/>0,<sp/><sp/>Eigen::VectorXd::Constant(1,<sp/>0.5));</highlight></codeline>
<codeline><highlight class="normal">auto<sp/>data<sp/>=<sp/>model.simulate(1e3);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">instantiate<sp/>a<sp/>gaussian<sp/>copula<sp/>with<sp/>default<sp/>parameters<sp/>and<sp/>fit<sp/>to<sp/>data</highlight></codeline>
<codeline><highlight class="normal">Bicop<sp/>fitted(BicopFamily::gaussian);</highlight></codeline>
<codeline><highlight class="normal">fitted.fit(data);</highlight></codeline>
<codeline><highlight class="normal">std::cout<sp/>&lt;&lt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;estimated<sp/>parameter:<sp/>&quot;<sp/>&lt;&lt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fitted.get_parameters()<sp/>&lt;&lt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::endl;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">assign<sp/>another<sp/>family<sp/>to<sp/>the<sp/>same<sp/>variable<sp/>and<sp/>fit<sp/>to<sp/>data</highlight></codeline>
<codeline><highlight class="normal">fitted<sp/>=<sp/>Bicop(BicopFamily::student);</highlight></codeline>
<codeline><highlight class="normal">fitted.fit(data);</highlight></codeline>
<codeline><highlight class="normal">std::cout<sp/>&lt;&lt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;estimated<sp/>parameter:<sp/>&quot;<sp/>&lt;&lt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fitted.get_parameters()<sp/>&lt;&lt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::endl;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">alternatively,<sp/>assign<sp/>to<sp/>a<sp/>family<sp/>and<sp/>fit<sp/>automatically</highlight></codeline>
<codeline><highlight class="normal">fitted.select(data);</highlight></codeline>
<codeline><highlight class="normal">std::cout<sp/>&lt;&lt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;family:<sp/>&quot;<sp/>&lt;&lt;<sp/>fitted.get_family_name()<sp/>&lt;&lt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;rotation:<sp/>&quot;<sp/>&lt;&lt;<sp/><sp/>fitted.get_rotation()<sp/>&lt;&lt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::endl;</highlight></codeline>
</programlisting></para><para>As it&apos;s arguably the most important function of the <computeroutput>Bicop</computeroutput> class, it&apos;s worth understanding the second argument of <computeroutput>select()</computeroutput>, namely an object of the class <computeroutput>FitControlsBicop</computeroutput>, which contain several data members:<itemizedlist>
<listitem><para><computeroutput>std::vector&lt;BicopFamily&gt; family_set</computeroutput> describes the set of family to select from. It can take a user specified vector of families or any of those mentioned above (default is <computeroutput>bicop_families::all</computeroutput>).</para></listitem><listitem><para><computeroutput>std::string parametric_method</computeroutput> describes the estimation method. It can take <computeroutput>&quot;mle&quot;</computeroutput> (default, for maximum-likelihood estimation) and <computeroutput>&quot;itau&quot;</computeroutput> (for Kendall&apos;s tau inversion, although only available for families included in <computeroutput>bicop_families::itau</computeroutput>).</para></listitem><listitem><para><computeroutput>std::string nonparametric_method</computeroutput> describes the degree of the density approximation for the transformation kernel estimator. It can take <computeroutput>constant</computeroutput>, <computeroutput>linear</computeroutput> and <computeroutput>quadratic</computeroutput> (default) for approximations of degree zero, one and two.</para></listitem><listitem><para><computeroutput>double nonparametric_mult</computeroutput> a factor with which the smoothing parameters are multiplied.</para></listitem><listitem><para><computeroutput>std::string selection_criterion</computeroutput> describes the criterion to compare the families. It can take either <computeroutput>&quot;loglik&quot;</computeroutput>, <computeroutput>&quot;aic&quot;</computeroutput>, or <computeroutput>&quot;bic&quot;</computeroutput>(default).</para></listitem><listitem><para><computeroutput>Eigen::VectorXd weights</computeroutput> an optional vector of weights for the observations.</para></listitem><listitem><para><computeroutput>bool preselect_families</computeroutput> describes a heuristic preselection method (default is <computeroutput>true</computeroutput>) based on symmetry properties of the data (e.g., the unrotated Clayton won&apos;t be preselected if the data displays upper-tail dependence).</para></listitem><listitem><para><computeroutput>size_t num_threads</computeroutput> number of threads to run in parallel when fitting several families.</para></listitem></itemizedlist>
</para><para>As mentioned <ulink url="#bicop-custom">above</ulink>, the arguments of <computeroutput>select()</computeroutput> can be used as arguments to a constructor allowing to instantiate a new object directly:</para><para><programlisting><codeline><highlight class="normal">//<sp/>instantiate<sp/>an<sp/>archimedean<sp/>copula<sp/>by<sp/>selecting<sp/>the<sp/>&quot;best&quot;<sp/>family<sp/>according<sp/>to</highlight></codeline>
<codeline><highlight class="normal">//<sp/>the<sp/>BIC<sp/>and<sp/>parameters<sp/>corresponding<sp/>to<sp/>the<sp/>MLE</highlight></codeline>
<codeline><highlight class="normal">Bicop<sp/>best_archimedean(data,<sp/>FitControlsBicop(bicop_families::archimedean));</highlight></codeline>
<codeline><highlight class="normal">std::cout<sp/>&lt;&lt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;family:<sp/>&quot;<sp/>&lt;&lt;<sp/>best_archimedean.get_family_name()<sp/>&lt;&lt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;rotation:<sp/>&quot;<sp/>&lt;&lt;<sp/><sp/>best_archimedean.get_rotation()<sp/>&lt;&lt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>best_archimedean.get_parameters()<sp/>&lt;&lt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::endl</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>instantiate<sp/>a<sp/>bivariate<sp/>copula<sp/>by<sp/>selecting<sp/>the<sp/>&quot;best&quot;<sp/>family<sp/>according<sp/>to</highlight></codeline>
<codeline><highlight class="normal">//<sp/>the<sp/>AIC<sp/>and<sp/>parameters<sp/>corresponding<sp/>to<sp/>Kendall&apos;s<sp/>tau<sp/>inversion</highlight></codeline>
<codeline><highlight class="normal">FitControlsBicop<sp/>controls(bicop_families::itau,<sp/>&quot;itau&quot;);</highlight></codeline>
<codeline><highlight class="normal">controls.set_selection_criterion(&quot;aic&quot;);</highlight></codeline>
<codeline><highlight class="normal">Bicop<sp/>best_itau(data,<sp/>controls));</highlight></codeline>
<codeline><highlight class="normal">std::cout<sp/>&lt;&lt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;family:<sp/>&quot;<sp/>&lt;&lt;<sp/>best_itau.get_family_name()<sp/>&lt;&lt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;rotation:<sp/>&quot;<sp/>&lt;&lt;<sp/><sp/>best_itau.get_rotation()<sp/>&lt;&lt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>best_itau.get_parameters()<sp/>&lt;&lt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::endl</highlight></codeline>
</programlisting></para></sect1>
<sect1 id="overview-bicop_1bicop-model">
<title>Work with a bivariate copula model</title>
<para>You can simulate from a model and evaluate the pdf, h-functions, inverse h-functions, log-likelihood, AIC, and BIC.</para><para><programlisting><codeline><highlight class="normal">//<sp/>Gauss<sp/>copula<sp/>with<sp/>parameter<sp/>0.5</highlight></codeline>
<codeline><highlight class="normal">Bicop<sp/>bicop(BicopFamily::gaussian,<sp/>0,<sp/><sp/>Eigen::VectorXd::Constant(1,<sp/>0.5));</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Simulate<sp/>100<sp/>observations</highlight></codeline>
<codeline><highlight class="normal">auto<sp/>sim_data<sp/>=<sp/>bicop.simulate(100);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Evaluate<sp/>the<sp/>pdf</highlight></codeline>
<codeline><highlight class="normal">auto<sp/>pdf<sp/><sp/>=<sp/>bicop.pdf(sim_data);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Evaluate<sp/>the<sp/>two<sp/>h-functions</highlight></codeline>
<codeline><highlight class="normal">auto<sp/>h1<sp/><sp/><sp/>=<sp/>bicop.hfunc1(sim_data);</highlight></codeline>
<codeline><highlight class="normal">auto<sp/>h2<sp/><sp/><sp/>=<sp/>bicop.hfunc2(sim_data);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Evalute<sp/>the<sp/>two<sp/>inverse<sp/>h-functions</highlight></codeline>
<codeline><highlight class="normal">auto<sp/>hi1<sp/><sp/>=<sp/>bicop.hinv1(sim_data);</highlight></codeline>
<codeline><highlight class="normal">auto<sp/>hi2<sp/><sp/>=<sp/>bicop.hinv2(sim_data);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Evaluate<sp/>the<sp/>log-likelihood,<sp/>AIC,<sp/>and<sp/>BIC</highlight></codeline>
<codeline><highlight class="normal">auto<sp/>ll<sp/><sp/><sp/>=<sp/>bicop.loglik(sim_data);</highlight></codeline>
<codeline><highlight class="normal">auto<sp/>aic<sp/><sp/>=<sp/>bicop.aic(sim_data);</highlight></codeline>
<codeline><highlight class="normal">auto<sp/>bic<sp/><sp/>=<sp/>bicop.bic(sim_data);</highlight></codeline>
</programlisting></para><para>Bivariate copula models can also be written to and constructed from JSON files and <computeroutput>boost::property_tree::ptree</computeroutput> objects:</para><para><programlisting><codeline><highlight class="normal">//<sp/>Gauss<sp/>copula<sp/>with<sp/>parameter<sp/>0.5</highlight></codeline>
<codeline><highlight class="normal">Bicop<sp/>bicop(BicopFamily::gaussian,<sp/>0,<sp/><sp/>Eigen::VectorXd::Constant(1,<sp/>0.5));</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Save<sp/>as<sp/>a<sp/>ptree<sp/>object</highlight></codeline>
<codeline><highlight class="normal">boost::property_tree::ptree<sp/>bicop_node<sp/>=<sp/>bicop.to_ptree();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Write<sp/>into<sp/>a<sp/>JSON<sp/>file</highlight></codeline>
<codeline><highlight class="normal">boost::property_tree::write_json(&quot;myfile.JSON&quot;,<sp/>bicop_node);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Equivalently</highlight></codeline>
<codeline><highlight class="normal">bicop.to_json(&quot;myfile.JSON&quot;);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Then<sp/>a<sp/>new<sp/>Bicop<sp/>can<sp/>be<sp/>constructed<sp/>from<sp/>the<sp/>ptree<sp/>object</highlight></codeline>
<codeline><highlight class="normal">Bicop<sp/>bicop2(bicop_node);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Or<sp/>from<sp/>the<sp/>JSON<sp/>file</highlight></codeline>
<codeline><highlight class="normal">Bicop<sp/>bicop3(&quot;myfile.JSON&quot;);</highlight></codeline>
</programlisting> </para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
